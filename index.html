<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Master | Final</title>
    
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            /* --- THEME VARIABLES --- */
            --bg-body: #0f172a; --bg-panel: #1e293b; --bg-input: #334155; --bg-hover: #475569;
            --text-main: #f8fafc; --text-muted: #94a3b8; --border-color: #334155;
            --primary: #3b82f6; --primary-text: #ffffff; --danger: #ef4444; --success: #22c55e;
            --warning: #f59e0b; 
            --radius: 12px; --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --resizer-bg: #475569;
        }

        body.light-mode {
            --bg-body: #f8fafc; --bg-panel: #ffffff; --bg-input: #f1f5f9; --bg-hover: #e2e8f0;
            --text-main: #0f172a; --text-muted: #64748b; --border-color: #e2e8f0;
            --primary: #2563eb; --resizer-bg: #cbd5e1;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background-color: var(--bg-body); color: var(--text-main);
            margin: 0; display: flex; height: 100vh; overflow: hidden;
            transition: background-color 0.4s ease;
        }

        /* --- LAYOUT --- */
        .main-container { display: flex; width: 100%; max-width: 100%; margin: 0; padding: 15px; height: 100vh; align-items: stretch; }

        .board-area {
            flex: 0 0 55%; min-width: 300px; display: flex; justify-content: center; align-items: center; flex-direction: column;
            padding: 10px; position: relative; z-index: 1; overflow: visible !important; 
        }

        /* Container für Balken + Brett */
        .board-wrapper {
            display: flex; gap: 10px; height: 100%; width: 100%; position: relative; z-index: 10;
            max-width: 85vh; max-height: 85vh; align-items: stretch; justify-content: center;
            position: relative; /* Wichtig für SVG Overlay */
        }

        #board {
            width: 100%; aspect-ratio: 1/1; 
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
            flex-shrink: 1;
            z-index: 1; /* Unter dem SVG */
        }

        /* Board uses default corners */

        /* Visual feedback when shapes are cleared via keyboard */
        #board.flash-clear-shapes {
            box-shadow: 0 0 0 6px rgba(245, 159, 11, 0.12), 0 20px 30px rgba(0,0,0,0.35);
            transition: box-shadow 0.18s ease;
        }

        /* SVG OVERLAY FÜR PFEILE */
        #arrow-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Klicks gehen durch */
            z-index: 1000; /* Über den Figuren */
        }

        /* WICHTIG: Damit Bilder immer sichtbar sind */
        #board img { 
            opacity: 1 !important;
            z-index: 100;
            visibility: visible !important;
        }

        #board img[src*="piece"] {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* DRAGGED PIECES ALWAYS ON TOP */
        #board img.dragging {
            opacity: 1 !important;
            z-index: 10000 !important;
            position: fixed !important;
            visibility: visible !important;
        }

        /* --- BRETT FARBTHEMEN --- */
        .board-theme-green .white-1e1d7 { background-color: #eeeed2; color: #769656; }
        .board-theme-green .black-3c85d { background-color: #769656; color: #eeeed2; }
        .board-theme-brown .white-1e1d7 { background-color: #f0d9b5; color: #b58863; }
        .board-theme-brown .black-3c85d { background-color: #b58863; color: #f0d9b5; }
        .board-theme-blue .white-1e1d7 { background-color: #dee3e6; color: #8ca2ad; }
        .board-theme-blue .black-3c85d { background-color: #8ca2ad; color: #dee3e6; }
        .board-theme-gray .white-1e1d7 { background-color: #e0e0e0; color: #707070; }
        .board-theme-gray .black-3c85d { background-color: #707070; color: #e0e0e0; }
        .board-theme-purple .white-1e1d7 { background-color: #e9d5ff; color: #8b5cf6; }
        .board-theme-purple .black-3c85d { background-color: #8b5cf6; color: #e9d5ff; }
        .board-theme-teal .white-1e1d7 { background-color: #ccfbf1; color: #0d9488; }
        .board-theme-teal .black-3c85d { background-color: #0d9488; color: #ccfbf1; }


        /* STOCKFISH EVAL BAR */
        #eval-bar-container {
            width: 30px; background: #333; 
            border-radius: 4px; overflow: hidden; position: relative;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
            flex-shrink: 0; display: flex; flex-direction: column; justify-content: flex-end;
            border: 1px solid var(--border-color);
        }
        #eval-fill {
            width: 100%; height: 50%; 
            background: #fff; 
            transition: height 0.5s ease-in-out;
        }
        #eval-score {
            position: absolute; 
            width: 100%; text-align: center; 
            font-size: 11px; font-weight: 800; 
            z-index: 2; pointer-events: none; line-height: 1; padding: 4px 0;
            font-family: monospace;
        }

        .highlight-square { box-shadow: inset 0 0 0 4px var(--highlight-last); }

        .resizer {
            width: 12px; cursor: col-resize; background-color: transparent; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s; margin: 0 4px; border-radius: 6px; flex-shrink: 0; z-index: 10;
        }
        .resizer::after { content: ""; width: 4px; height: 40px; background-color: var(--resizer-bg); border-radius: 2px; transition: height 0.2s, background-color 0.2s; }
        .resizer:hover, .resizer.dragging { background-color: var(--bg-hover); }
        .resizer:hover::after, .resizer.dragging::after { height: 100%; background-color: var(--primary); }

        .controls-area {
            flex: 1; min-width: 350px; background-color: var(--bg-panel); border-radius: var(--radius);
            box-shadow: var(--shadow); display: flex; flex-direction: column; height: 100%; overflow: hidden;
        }
        .header-row {
            display: flex; justify-content: space-between; align-items: center; padding: 20px 25px; border-bottom: 1px solid var(--border-color); flex-shrink: 0;
        }
        h2 { margin: 0; font-size: 1.1rem; font-weight: 700; display: flex; align-items: center; gap: 10px; color: var(--text-main); letter-spacing: -0.5px; }
        h2 i { color: var(--primary); }
        .settings-btn { background: none; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer; transition: 0.3s; }
        .settings-btn:hover { color: var(--text-main); transform: rotate(90deg); }

        #view-mode, #settings-mode, #add-mode, #selection-mode, #train-mode, #bot-setup-mode, #bot-play-mode { display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 25px; }
        .scrollable-list, .settings-container, #selection-list { flex-grow: 1; overflow-y: auto; min-height: 0; padding-right: 8px; margin-bottom: 20px; }
        
        .action-group { margin-top: auto; flex-shrink: 0; display: flex; gap: 12px; flex-wrap: wrap; }
        .action-group { justify-content: center; }

        /* TRAINING UI */
        .training-dashboard { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; padding-bottom: 20px; width: 100%; }
        .training-card { background: var(--bg-input); border-radius: var(--radius); padding: 18px; width: 100%; text-align: center; box-shadow: var(--shadow); border: 1px solid var(--border-color); }
        /* Center training card on larger screens */
        #train-mode .training-dashboard { justify-content: center; align-items: center; }
        #train-mode .training-card { max-width: 520px; margin: 0 auto; }
        /* Ensure the training card fits inside the menu area and doesn't force page scrolling */
        #train-mode { overflow: hidden; }
        #train-mode .training-dashboard { justify-content: flex-start; align-items: stretch; overflow: auto; padding-bottom: 12px; }
        #train-mode .training-card { max-height: calc(100% - 20px); overflow-y: auto; box-sizing: border-box; }
        .category-label { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted); margin-bottom: 10px; font-weight: 600; }
        .active-category-title { font-size: 1.4rem; font-weight: 700; color: var(--text-main); margin: 0 0 20px 0; }
        .progress-container { width: 100%; height: 6px; background: var(--bg-panel); border-radius: 4px; overflow: hidden; margin-bottom: 18px; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.5s ease; }
        .progress-text { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 5px; display: flex; justify-content: space-between; }
        
        .status-badge { display: inline-block; padding: 10px 20px; border-radius: 30px; font-size: 1.15rem; font-weight: 800; background: var(--bg-panel); color: var(--text-main); border: 2px solid var(--border-color); transition: all 0.3s; }
        .status-badge.success { background: rgba(34, 197, 94, 0.2); color: var(--success); border-color: var(--success); }
        .status-badge.error { background: rgba(239, 68, 68, 0.2); color: var(--danger); border-color: var(--danger); animation: shake 0.4s; }
        .status-badge.neutral { background: var(--bg-input); color: var(--primary); border-color: var(--primary); }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        .training-note { 
            background: var(--bg-panel); border-left: 6px solid var(--primary); 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2); 
            padding: 20px; margin-top: 25px; border-radius: var(--radius);
            color: var(--text-main); width: 100%; max-width: 800px; 
            display: none; font-size: 1.1rem; line-height: 1.6; 
            flex-direction: column; gap: 15px; position: relative; z-index: 10;
        }
        .note-content { display: flex; align-items: flex-start; gap: 15px; }
        .note-content i { color: var(--primary); margin-top: 4px; font-size: 1.3rem; }
        .continue-btn { align-self: flex-end; background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: var(--radius); font-weight: 600; cursor: pointer; font-size: 0.95rem; display: flex; align-items: center; gap: 8px; transition: 0.2s; }
        .continue-btn:hover { background: #2563eb; transform: translateY(-1px); }

        /* LISTS */
        .category-group { margin-bottom: 8px; }
        .category-header { font-size: 0.9rem; font-weight: 600; color: var(--text-main); margin-bottom: 2px; display: flex; align-items: center; justify-content: space-between; padding: 12px 10px; border-radius: var(--radius); cursor: pointer; transition: background 0.2s; }
        .category-header:hover { background: var(--bg-hover); }
        .category-header i.fa-chevron-right { color: var(--text-muted); font-size: 0.8rem; margin-right: 12px; transition: transform 0.2s; }
        .category-header.expanded i.fa-chevron-right { transform: rotate(90deg); color: var(--text-main); }
        .category-header.special-cat { border-left: 4px solid var(--warning); background: rgba(245, 158, 11, 0.1); }
        .category-header.special-cat span { color: var(--warning); }
        .category-content { display: none; padding-left: 12px; margin-top: 2px; }
        .category-content.expanded { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        .line-item { background: transparent; padding: 12px; border-radius: var(--radius); cursor: pointer; display: flex; justify-content: space-between; align-items: flex-start; font-size: 0.95rem; transition: all 0.2s ease; margin-bottom: 2px; }
        .line-item:hover { background: var(--bg-input); }
        .line-item.in-repetition { background: rgba(245, 158, 11, 0.08); }
        
        .line-item > span:first-child { 
            flex: 1 1 auto; min-width: 0; 
            white-space: normal; word-break: break-word; line-height: 1.5; 
            padding-right: 10px; 
        }
        .line-actions { flex: 0 0 auto; display: flex; gap: 5px; opacity: 0; transition: 0.2s; }

        .line-item input[type="checkbox"] { accent-color: var(--primary); transform: scale(1.3); margin-right: 15px; cursor: pointer; margin-top: 3px; flex-shrink: 0; }
        
        .cat-actions { opacity: 0; transition: opacity 0.2s ease; display: flex; gap: 5px; flex-shrink: 0; }
        .category-header:hover .cat-actions, .line-item:hover .line-actions { opacity: 1; }
        @media (hover: none) { .cat-actions, .line-actions { opacity: 1; } }
        .cat-actions button, .line-actions button { background: transparent; border: none; color: var(--text-muted); cursor: pointer; padding: 6px; border-radius: 4px; font-size: 0.9rem; transition: 0.2s; }
        .cat-actions button:hover, .line-actions button:hover { color: var(--primary); background: var(--bg-input); }
        .cat-actions button.del:hover, .line-actions button.del:hover { color: var(--danger); }
        .line-actions button.toggle-rep:hover { color: var(--warning); }

        /* BUTTONS & INPUTS */
        .action-btn { background-color: var(--text-main); color: var(--bg-body); border: none; padding: 14px 24px; border-radius: var(--radius); font-weight: 700; cursor: pointer; flex: 1; display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s; font-size: 1rem; }
        .action-btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .action-btn.secondary { background-color: var(--bg-input); color: var(--text-main); }
        .action-btn.secondary:hover { background-color: var(--bg-hover); }
        
        .action-btn.repetition { background-color: transparent; border: 2px solid var(--warning); color: var(--warning); width: 100%; flex: 1 1 100%; order: -1; opacity: 0.8; }
        .action-btn.repetition:hover, .action-btn.repetition:active { opacity: 1; background: var(--warning); color: #000; }
        
        .action-btn.remove-repetition { background-color: transparent; border: 2px solid var(--success); color: var(--success); width: 100%; flex: 1 1 100%; order: -1; }
        .action-btn.remove-repetition:hover { background: var(--success); color: #fff; }

        input[type="text"], input[type="search"], textarea.note-input { width: 100%; padding: 14px; margin-bottom: 12px; background: var(--bg-input); border: 2px solid transparent; color: var(--text-main); border-radius: var(--radius); font-size: 1rem; transition: 0.2s; flex-shrink: 0; font-family: inherit; }
        input:focus, textarea:focus { outline: none; background: var(--bg-panel); border-color: var(--primary); }
        textarea.note-input { height: 100px; resize: none; margin-top: 5px; }

        /* SLIDER STYLE */
        input[type="range"] { appearance: none; -webkit-appearance: none; width: 100%; background: transparent; margin: 15px 0; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: var(--primary); cursor: pointer; margin-top: -8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 8px; cursor: pointer; background: var(--bg-input); border-radius: 4px; }
        
        .settings-section { margin-bottom: 30px; }
        .settings-label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 12px; color: var(--text-muted); }
        .options-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .options-grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .option-card { background: var(--bg-input); border: 2px solid transparent; padding: 15px; border-radius: var(--radius); cursor: pointer; text-align: center; font-size: 0.85rem; font-weight: 500; color: var(--text-main); transition: 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .option-card:hover { background: var(--bg-hover); } .option-card.selected { border-color: var(--primary); color: var(--primary); background: var(--bg-panel); }
        .toggle-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--border-color); cursor: pointer; }
        .toggle-switch { width: 44px; height: 24px; background: var(--bg-input); border-radius: 12px; position: relative; transition: 0.3s; }
        .toggle-switch::after { content: ''; position: absolute; left: 2px; top: 2px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: 0.3s; }
        .toggle-row.active .toggle-switch { background: var(--primary); } .toggle-row.active .toggle-switch::after { left: 22px; }
        .color-dot { width: 20px; height: 20px; border-radius: 50%; display: inline-block; }
        .color-switch { display: flex; background: var(--bg-input); border-radius: var(--radius); padding: 4px; margin-bottom: 20px; flex-shrink: 0; }
        .color-btn { flex: 1; background: transparent; border: none; color: var(--text-muted); padding: 10px; cursor: pointer; font-weight: 600; border-radius: 6px; font-size: 0.95rem; }
        .color-btn.active { background-color: var(--bg-panel); color: var(--text-main); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .search-banner { background: var(--bg-input); padding: 12px 15px; border-radius: var(--radius); margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; color: var(--text-main); font-size: 0.95rem; flex-shrink: 0;}
        .search-banner button { background: none; border: none; color: var(--text-muted); font-weight: 600; cursor: pointer; }
        .search-banner button:hover { color: var(--danger); }
        ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: var(--bg-input); border-radius: 4px; } ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        .hidden { display: none !important; }

                /* TRAINING RESULTS OVERLAY */
        .training-results-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.4s ease;
        }

        .results-card {
            background: var(--bg-panel);
            border-radius: var(--radius);
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .results-header {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 140px; /* keep title/subtitle visually centered in the card */
        }

        .results-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .results-icon.perfect { color: var(--success); }
        .results-icon.good { color: var(--primary); }
        .results-icon.needs-work { color: var(--warning); }

        .results-title {
            font-size: 2rem;
            font-weight: 800;
            margin: 0 0 10px 0;
            color: var(--text-main);
        }

        .results-subtitle {
            font-size: 1rem;
            color: var(--text-muted);
            margin: 0;
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-box {
            background: var(--bg-input);
            padding: 20px;
            border-radius: var(--radius);
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .stat-box:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 0;
            line-height: 1;
        }

        .stat-value.success-color { color: var(--success); }
        .stat-value.danger-color { color: var(--danger); }
        .stat-value.primary-color { color: var(--primary); }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .wrong-lines-section {
            background: var(--bg-input);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid var(--warning);
        }

        .wrong-lines-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--warning);
            font-weight: 700;
            font-size: 1.1rem;
        }

        .wrong-lines-list {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .wrong-line-item {
            background: var(--bg-panel);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: var(--text-main);
            border: 1px solid var(--border-color);
        }

        .results-question {
            text-align: center;
            font-size: 1.1rem;
            color: var(--text-main);
            margin-bottom: 20px;
            font-weight: 600;
        }

        .results-actions {
            display: flex;
            gap: 12px;
        }

        .results-btn {
            flex: 1;
            padding: 16px 24px;
            border: none;
            border-radius: var(--radius);
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .results-btn.primary {
            background: var(--warning);
            color: #000;
        }

        .results-btn.primary:hover {
            background: #d97706;
            transform: translateY(-2px);
        }

        .results-btn.secondary {
            background: var(--bg-input);
            color: var(--text-main);
        }

        .results-btn.secondary:hover {
            background: var(--bg-hover);
            transform: translateY(-2px);
        }

        .no-wrong-lines {
            text-align: center;
            padding: 30px;
        }

        .no-wrong-lines i {
            font-size: 3rem;
            color: var(--success);
            margin-bottom: 15px;
        }

        .no-wrong-lines p {
            font-size: 1.2rem;
            color: var(--text-main);
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        .no-wrong-lines span {
            color: var(--text-muted);
            font-size: 0.95rem;
        }
        
        /* Mobile layout: board on top, menu below, avoid page scroll */
        @media (max-width: 768px) {
            body { overflow: hidden; }
            .main-container { flex-direction: column; padding: 8px; height: 100vh; }

            .board-area {
                flex: 0 0 50vh;
                min-width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 6px;
                order: 0;
                overflow: hidden; /* prevent board growing beyond its area */
            }

            .board-wrapper {
                max-width: 100%;
                max-height: 100%;
                width: 100%;
                height: 100%;
                align-items: center;
                justify-content: center;
            }

            #board {
                /* Keep the board square but constrained to its container */
                width: auto;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
                aspect-ratio: 1 / 1;
                box-sizing: border-box;
            }

            .resizer { display: none; }

            .controls-area {
                flex: 1 1 auto;
                min-width: 100%;
                order: 1;
                height: calc(100vh - 50vh - 16px);
                padding: 12px;
                /* leave space for the fixed action bar */
                padding-bottom: calc(92px + env(safe-area-inset-bottom));
                overflow: auto;
            }

            /* Make key UI elements more compact on small screens */
            .training-card { padding: 16px; }
            .header-row { padding: 12px 16px; }
            .action-group { gap: 8px; }

            /* Ensure overlays scale on mobile */
            .training-results-overlay .results-card { max-width: 95%; padding: 20px; }
            /* Make lists inside controls scroll independently and only when needed */
            .controls-area .scrollable-list,
            #lines-list,
            #selection-list,
            .settings-container {
                max-height: calc(100vh - 50vh - 140px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Hide the clear-shapes button when creating a new line on phones */
            #add-mode .clear-shapes-btn { display: none; }

            /* Enable touch dragging on the board and pieces */
            #board { touch-action: none; -ms-touch-action: none; }
            #board img { -webkit-user-drag: none; touch-action: none; }
        }

        /* Mobile-specific tweaks for add/view/train modes */
        @media (max-width: 768px) {
            /* PGN/move list in Add Mode should scroll so played moves are visible */
            #add-mode #pgn-display {
                max-height: calc(28vh);
                overflow-y: auto;
                padding: 10px;
                border-radius: 8px;
                -webkit-overflow-scrolling: touch;
                background: var(--bg-input);
            }

            /* Make training progress area smaller so more of the card is visible */
            #train-mode .training-card { padding: 12px; }
            #train-mode .progress-container { height: 6px; }
            #train-mode .active-category-title { font-size: 1.1rem; }

            /* Center the primary view buttons and keep them static (not in fixed bottom bar) */
            #view-mode .action-group,
            #add-mode .action-group {
                position: relative !important;
                left: auto !important;
                right: auto !important;
                bottom: auto !important;
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 12px;
                padding: 0;
            }

            /* Ensure the fixed bottom action bar doesn't cover these modes */
            #view-mode .action-group .action-btn,
            #add-mode .action-group .action-btn { min-width: 120px; }
        }

        /* Add-mode scrolling and limits (all screens) so played moves and notes remain visible */
        #add-mode { overflow-y: auto; }
        #add-mode #pgn-display { max-height: 30vh; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        #add-mode .note-input { max-height: 24vh; overflow-y: auto; }


        /* Mobile fixed action bar: keep bottom buttons always reachable */
        @media (max-width: 768px) {
            .action-group {
                position: fixed;
                left: 12px;
                right: 12px;
                bottom: calc(12px + env(safe-area-inset-bottom));
                display: flex;
                gap: 8px;
                padding: 8px;
                z-index: 1000;
                background: linear-gradient(180deg, rgba(0,0,0,0.0), rgba(0,0,0,0.06));
                border-radius: 12px;
                backdrop-filter: blur(6px);
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .action-group .action-btn {
                flex: 0 0 auto;
                min-width: 110px;
            }
        }
        /* Ensure training card is centered on larger screens (override earlier rules) */
        @media (min-width: 1024px) {
            #train-mode .training-dashboard { justify-content: center !important; align-items: center !important; }
            #train-mode .training-card { margin: 0 auto !important; max-width: 520px; }
        }
    </style>
</head>
<body class="" onmousedown="initAudio()">

<div class="main-container" id="main-container">
    <div class="board-area" id="board-area">
        <div class="board-wrapper" id="board-wrapper">
            <div id="eval-bar-container" class="hidden">
                <div id="eval-score">0.0</div>
                <div id="eval-fill"></div>
            </div>
            <svg id="arrow-overlay"></svg>
            <div id="board" class="board-theme-green"></div>
        </div>

        <div id="training-note-display" class="training-note">
            <div class="note-content">
                <i class="fas fa-info-circle"></i>
                <span id="note-text" style="flex:1;"></span>
            </div>
            <button class="continue-btn" onclick="continueFromNote()">Weiter</button>
        </div>
    </div>

    <div class="resizer" id="resizer"></div>

    <div class="controls-area" id="controls-area">
        <div class="header-row">
            <h2><i class="fas fa-chess-knight"></i> Trainer</h2>
            <button class="settings-btn" onclick="openSettings()" title="Einstellungen"><i class="fas fa-gear"></i></button>
        </div>

        <div id="view-mode">
            <div class="color-switch">
                <button class="color-btn active" onclick="setSide('white')">Weiß</button>
                <button class="color-btn" onclick="setSide('black')">Schwarz</button>
            </div>
            <div id="search-active-banner" class="search-banner hidden">
                <span><i class="fas fa-filter" style="margin-right:8px; color:var(--primary)"></i> Filter aktiv</span>
                <button onclick="resetBoardSearch()">Reset</button>
            </div>
            <div id="lines-list" class="scrollable-list"></div>
            <div class="action-group">
                <button class="action-btn" onclick="startAddingLine()"><i class="fas fa-plus"></i> Neu</button>
                <button class="action-btn secondary" onclick="openSelectionMode()"><i class="fas fa-play"></i> Üben</button>
            </div>
        </div>

        <div id="bot-setup-mode" class="hidden">
             <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; flex-shrink: 0;">
                <h2 style="font-size:1.1rem; margin:0;">Gegen Bot spielen</h2>
            </div>
            <div class="settings-container">
                <div class="training-card" style="margin-bottom:20px;">
                    <div class="category-label">Bot Stärke (ELO)</div>
                    <div class="active-category-title" id="elo-display">1500</div>
                    <input type="range" id="elo-slider" min="500" max="3300" step="50" value="1500" oninput="updateEloDisplay(this.value)">
                    <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:var(--text-muted);">
                        <span>Anfänger (500)</span>
                        <span>Großmeister (3300)</span>
                    </div>
                </div>
                
                <div class="training-card">
                    <div class="category-label">Ausgewählte Variante</div>
                    <div id="bot-line-preview" style="font-style:italic; margin-top:10px; line-height:1.4;"></div>
                </div>
            </div>
             <div class="action-group">
                <button class="action-btn" onclick="launchBotGame()"><i class="fas fa-robot"></i> Spiel starten</button>
                <button class="action-btn secondary" onclick="switchUI('view-mode')">Abbrechen</button>
            </div>
        </div>

        <div id="bot-play-mode" class="hidden">
            <div class="training-dashboard">
                <div class="training-card">
                    <div class="category-label">Gegner</div>
                    <div class="active-category-title">Stockfish <span style="font-size:1rem; color:var(--text-muted);" id="bot-play-elo"></span></div>
                    <div class="status-badge neutral" id="bot-status">Viel Erfolg!</div>
                </div>
            </div>
            <div class="action-group">
                <button class="action-btn secondary" onclick="stopBotGame()" style="color:var(--danger);">Spiel beenden</button>
            </div>
        </div>

        <div id="settings-mode" class="hidden">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; flex-shrink: 0;">
                <h2 style="font-size:1.1rem; margin:0;">Einstellungen</h2>
                <button class="settings-btn" onclick="closeSettings()"><i class="fas fa-times"></i></button>
            </div>
            <div class="settings-container">
                <div class="settings-section">
                    <span class="settings-label">Datenverwaltung (Speichern & Laden)</span>
                    <div style="background: var(--bg-input); padding: 15px; border-radius: var(--radius); text-align: center;">
                        <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 15px;">
                            Deine Daten werden automatisch in diesem Browser gespeichert. 
                            Um sie auf ein anderes Gerät zu übertragen, nutze diese Buttons:
                        </p>
                        <div style="display: flex; gap: 10px;">
                            <button class="action-btn secondary" onclick="exportData()"><i class="fas fa-download"></i> Backup speichern</button>
                            <button class="action-btn secondary" onclick="document.getElementById('import-file').click()"><i class="fas fa-upload"></i> Backup laden</button>
                            <input type="file" id="import-file" style="display: none;" onchange="importData(this)">
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <span class="settings-label">Darstellung</span>
                    <div class="toggle-row" onclick="toggleThemeSetting()" id="setting-theme-row"><span>Dark Mode</span><div class="toggle-switch"></div></div>
                </div>
                <div class="settings-section">
                    <span class="settings-label">Gameplay</span>
                    <div class="toggle-row" onclick="toggleSetting('sound')" id="setting-sound-row"><span>Soundeffekte</span><div class="toggle-switch"></div></div>
                    <div class="toggle-row" onclick="toggleSetting('coords')" id="setting-coords-row"><span>Koordinaten</span><div class="toggle-switch"></div></div>
                    <div class="toggle-row" onclick="toggleSetting('highlight')" id="setting-highlight-row"><span>Zug hervorheben</span><div class="toggle-switch"></div></div>
                    <div class="toggle-row" onclick="toggleSetting('autoRepeat')" id="setting-autorepeat-row"><span>Auto-Wiederholung bei Fehler</span><div class="toggle-switch"></div></div>
                    <div class="toggle-row" onclick="toggleEngine()" id="setting-engine-row"><span><i class="fas fa-microchip"></i> Stockfish Analyse</span><div class="toggle-switch"></div></div>
                </div>
                <div class="settings-section">
                    <span class="settings-label">Animationen</span>
                    <div class="options-grid">
                        <div class="option-card" onclick="setAnimSpeed(300)" id="opt-anim-300">Slow</div>
                        <div class="option-card" onclick="setAnimSpeed(200)" id="opt-anim-200">Normal</div>
                        <div class="option-card" onclick="setAnimSpeed(0)" id="opt-anim-0">Aus</div>
                    </div>
                </div>
                <div class="settings-section">
                    <span class="settings-label">Brett Design</span>
                    <div class="options-grid">
                        <div class="option-card" onclick="setBoardColor('green')" id="opt-board-green"><span class="color-dot" style="background:#769656;"></span></div>
                        <div class="option-card" onclick="setBoardColor('brown')" id="opt-board-brown"><span class="color-dot" style="background:#b58863;"></span></div>
                        <div class="option-card" onclick="setBoardColor('blue')" id="opt-board-blue"><span class="color-dot" style="background:#8ca2ad;"></span></div>
                        <div class="option-card" onclick="setBoardColor('gray')" id="opt-board-gray"><span class="color-dot" style="background:#707070;"></span></div>
                        <div class="option-card" onclick="setBoardColor('purple')" id="opt-board-purple"><span class="color-dot" style="background:#8b5cf6;"></span></div>
                        <div class="option-card" onclick="setBoardColor('teal')" id="opt-board-teal"><span class="color-dot" style="background:#0d9488;"></span></div>
                    </div>
                </div>
                <div class="settings-section">
                    <span class="settings-label">Figuren</span>
                    <div class="options-grid">
                        <div class="option-card" onclick="setPieceTheme('wikipedia')" id="opt-piece-wikipedia">Standard</div>
                        <div class="option-card" onclick="setPieceTheme('alpha')" id="opt-piece-alpha">Alpha</div>
                        <div class="option-card" onclick="setPieceTheme('uscf')" id="opt-piece-uscf">USCF</div>
                        <div class="option-card" onclick="setPieceTheme('merida')" id="opt-piece-merida">Merida</div>
                        <div class="option-card" onclick="setPieceTheme('maestro')" id="opt-piece-maestro">Maestro</div>
                        <div class="option-card" onclick="setPieceTheme('leipzig')" id="opt-piece-leipzig">Leipzig</div>
                        <div class="option-card" onclick="setPieceTheme('tatiana')" id="opt-piece-tatiana">Tatiana</div>
                        <div class="option-card" onclick="setPieceTheme('cardinal')" id="opt-piece-cardinal">Cardinal</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="add-mode" class="hidden">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; flex-shrink:0;">
                <h2 style="margin:0; font-size:1.1rem;">Neue Variante</h2>
            </div>
            <input type="text" id="category-input" list="category-datalist" placeholder="Kategorie (z.B. Sizilianisch)...">
            <datalist id="category-datalist"></datalist>
            
            <textarea id="move-note-input" class="note-input" placeholder="Notiz zu dieser Stellung..."></textarea>
            
            <button class="action-btn secondary clear-shapes-btn" onclick="clearShapesForCurrentPos()" style="margin-top:10px; margin-bottom:10px; padding: 10px;">
                <i class="fas fa-eraser"></i> Pfeile löschen
            </button>

            <div style="font-size:0.9rem; color:var(--text-muted); margin: 10px 0;"><i class="fas fa-info-circle"></i> Züge auf dem Brett ausführen</div>
            <div id="pgn-display" style="background: var(--bg-input); padding:15px; border-radius:var(--radius); font-family:monospace; margin-bottom:15px; flex-grow:1; overflow-y:auto; font-size:0.9rem; color:var(--text-main); min-height: 60px;"></div>
            <div class="action-group">
                <button class="action-btn" onclick="saveLine()" id="save-btn">Speichern</button>
                <button class="action-btn secondary" onclick="cancelAdd()">Abbrechen</button>
            </div>
        </div>

        <div id="selection-mode" class="hidden">
            <h2 style="font-size:1.1rem; margin-bottom:15px; flex-shrink:0;">Training Auswahl</h2>
            <input type="search" id="search-input" placeholder="Suche..." oninput="renderSelectionList()">
            <div id="selection-list" class="scrollable-list"></div>
            <div class="action-group">
                <button class="action-btn" onclick="startTrainingFromSelection()">Starten</button>
                <button class="action-btn secondary" onclick="switchUI('view-mode')">Zurück</button>
            </div>
        </div>

        <div id="train-mode" class="hidden">
            <div class="training-dashboard">
                <div class="training-card">
                    <div class="progress-text">
                        <span id="progress-text-left">Fortschritt</span>
                        <span id="progress-text-right">0 / 0</span>
                    </div>
                    <div class="progress-container">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>

                    <div class="category-label">Aktuelle Variante</div>
                    <div class="active-category-title" id="train-category-display"></div>
                    
                    <div class="status-badge neutral" id="train-status">Du bist dran</div>
                </div>
            </div>
            
            <div class="action-group">
                <button class="action-btn repetition" id="train-toggle-btn" onclick="toggleRepetitionStatus()">
                    <i class="fas fa-bookmark"></i> Wiederholung
                </button>
                <button class="action-btn secondary" onclick="repeatLater()">Später</button>
                <button class="action-btn secondary" onclick="stopTraining()" style="color:var(--danger);">Beenden</button>
            </div>
        </div>
    </div>
</div>

<!-- TRAINING RESULTS OVERLAY -->
<div class="training-results-overlay" id="training-results-overlay">
    <div class="results-card">
        <div class="results-header">
            <div class="results-icon" id="results-icon">
                <i class="fas fa-trophy"></i>
            </div>
            <h2 class="results-title" id="results-title">Training abgeschlossen!</h2>
            <p class="results-subtitle" id="results-subtitle">Großartige Leistung!</p>
        </div>

        <div class="results-stats">
            <div class="stat-box">
                <div class="stat-value success-color" id="stat-correct">0</div>
                <div class="stat-label">Richtig</div>
            </div>
            <div class="stat-box">
                <div class="stat-value danger-color" id="stat-wrong">0</div>
                <div class="stat-label">Falsch</div>
            </div>
            <div class="stat-box">
                <div class="stat-value primary-color" id="stat-accuracy">0%</div>
                <div class="stat-label">Genauigkeit</div>
            </div>
        </div>

        <div id="wrong-lines-container"></div>

        <div class="results-actions" id="results-actions">
            <button class="results-btn secondary" onclick="closeTrainingResults()">
                <i class="fas fa-times"></i> Schließen
            </button>
        </div>
    </div>
</div>

<script>
    // --- RESIZER LOGIC ---
    const resizer = document.getElementById('resizer');
    const boardArea = document.getElementById('board-area');
    const container = document.getElementById('main-container');
    let isResizing = false;
    resizer.addEventListener('mousedown', (e) => { isResizing = true; document.body.style.cursor = 'col-resize'; resizer.classList.add('dragging'); e.preventDefault(); });
    document.addEventListener('mousemove', (e) => { if (!isResizing) return; const containerWidth = container.getBoundingClientRect().width; let newFlex = (e.clientX / containerWidth) * 100; if(newFlex < 30) newFlex = 30; if(newFlex > 70) newFlex = 70; boardArea.style.flex = `0 0 ${newFlex}%`; if(board) board.resize(); });
    document.addEventListener('mouseup', () => { if(isResizing) { isResizing = false; document.body.style.cursor = ''; resizer.classList.remove('dragging'); if(board) board.resize(); } });

    // --- AUDIO ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function initAudio() { if (audioCtx.state === 'suspended') { audioCtx.resume(); } }

    function playSound(type) {
        if(!userSettings.sound) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain(); osc.connect(gainNode); gainNode.connect(audioCtx.destination);
        if (type === 'move') { osc.type = 'sine'; osc.frequency.setValueAtTime(300, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.05); gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05); osc.start(); osc.stop(audioCtx.currentTime + 0.05); } 
        else if (type === 'capture') {
            // Deep capture: use move's base frequency as starting point, ramp down for weight
            const baseStart = 300; // match move base
            const baseEnd = 40;    // deep final frequency

            // Main thud (uses move-like start frequency, ramps down)
            const thudFilter = audioCtx.createBiquadFilter();
            thudFilter.type = 'lowpass';
            thudFilter.frequency.setValueAtTime(240, audioCtx.currentTime);

            const thud = audioCtx.createOscillator();
            const thudGain = audioCtx.createGain();
            thud.type = 'sine';
            thud.frequency.setValueAtTime(baseStart, audioCtx.currentTime);
            thud.frequency.exponentialRampToValueAtTime(baseEnd, audioCtx.currentTime + 0.18);
            thudGain.gain.setValueAtTime(0.7, audioCtx.currentTime);
            thudGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);
            thud.connect(thudFilter); thudFilter.connect(thudGain); thudGain.connect(audioCtx.destination);
            thud.start(); thud.stop(audioCtx.currentTime + 0.7);

            // Sub oscillator for depth
            const sub = audioCtx.createOscillator();
            const subGain = audioCtx.createGain();
            sub.type = 'sine';
            sub.frequency.setValueAtTime(30, audioCtx.currentTime);
            subGain.gain.setValueAtTime(0.22, audioCtx.currentTime);
            subGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.9);
            sub.connect(subGain); subGain.connect(audioCtx.destination);
            sub.start(); sub.stop(audioCtx.currentTime + 0.9);

            // Soft bell accent (low volume)
            const bell = audioCtx.createOscillator();
            const bellGain = audioCtx.createGain();
            bell.type = 'triangle';
            bell.frequency.setValueAtTime(800, audioCtx.currentTime);
            bell.frequency.exponentialRampToValueAtTime(380, audioCtx.currentTime + 0.06);
            bellGain.gain.setValueAtTime(0.06, audioCtx.currentTime);
            bellGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
            bell.connect(bellGain); bellGain.connect(audioCtx.destination);
            bell.start(); bell.stop(audioCtx.currentTime + 0.18);

            // Subtle click to emphasize impact
            const clickBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.02, audioCtx.sampleRate);
            const data = clickBuf.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.005));
            const click = audioCtx.createBufferSource();
            const clickGain = audioCtx.createGain();
            click.buffer = clickBuf; click.connect(clickGain); clickGain.connect(audioCtx.destination);
            clickGain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            click.start(); click.stop(audioCtx.currentTime + 0.02);
        }
        else if (type === 'error') { osc.type = 'sine'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2); osc.start(); osc.stop(audioCtx.currentTime + 0.2); }
    }

    let userSettings = JSON.parse(localStorage.getItem('chessSettingsPro')) || { theme: 'dark', sound: true, coords: true, highlight: true, autoRepeat: false, animSpeed: 200, boardColor: 'green', pieceStyle: 'wikipedia' };
    
    // Safety Reset for old bad settings
    if(userSettings.pieceStyle === 'dubrovnik') { userSettings.pieceStyle = 'wikipedia'; localStorage.setItem('chessSettingsPro', JSON.stringify(userSettings)); }

    let expandedCategories = {}; 
    let isPaused = false; 
    let pendingNextAction = null; 
    let totalTrainingLines = 0;
    const REPETITION_CAT = "Wiederholung"; 
    let trainingStats = {
    correct: 0,
    wrong: 0,
    wrongLines: []
    };
    
    // --- BOT GAME VARIABLES ---
    let botGameActive = false;
    let botElo = 1500;
    let selectedBotLine = null;
    let isBotThinking = false; // LOCK VARIABLE FOR SYNC

    function updateSettingsUI() {
        document.getElementById('setting-theme-row').classList.toggle('active', userSettings.theme === 'dark'); 
        document.getElementById('setting-sound-row').classList.toggle('active', userSettings.sound);
        document.getElementById('setting-coords-row').classList.toggle('active', userSettings.coords);
        document.getElementById('setting-highlight-row').classList.toggle('active', userSettings.highlight);
        document.getElementById('setting-autorepeat-row').classList.toggle('active', userSettings.autoRepeat);
        
        // Stockfish Toggle
        const engineRow = document.getElementById('setting-engine-row');
        if(engineRow) engineRow.classList.toggle('active', isEngineRunning);

        document.querySelectorAll('.option-card').forEach(el => el.classList.remove('selected'));
        if(document.getElementById(`opt-anim-${userSettings.animSpeed}`)) document.getElementById(`opt-anim-${userSettings.animSpeed}`).classList.add('selected');
        if(document.getElementById(`opt-board-${userSettings.boardColor}`)) document.getElementById(`opt-board-${userSettings.boardColor}`).classList.add('selected');
        if(document.getElementById(`opt-piece-${userSettings.pieceStyle}`)) document.getElementById(`opt-piece-${userSettings.pieceStyle}`).classList.add('selected');
    }
    function applySettings() {
        if (userSettings.theme === 'light') document.body.classList.add('light-mode'); else document.body.classList.remove('light-mode');
        document.getElementById('board').className = `board-theme-${userSettings.boardColor}`;
        if(board) initBoard();
        updateSettingsUI();
    }
    function toggleSetting(key) { userSettings[key] = !userSettings[key]; saveSettings(); applySettings(); }
    function toggleThemeSetting() { userSettings.theme = userSettings.theme === 'light' ? 'dark' : 'light'; saveSettings(); applySettings(); }
    function setAnimSpeed(speed) { userSettings.animSpeed = speed; saveSettings(); applySettings(); }
    function setBoardColor(c) { userSettings.boardColor = c; saveSettings(); applySettings(); }
    function setPieceTheme(s) { userSettings.pieceStyle = s; saveSettings(); applySettings(); }
    function saveSettings() { localStorage.setItem('chessSettingsPro', JSON.stringify(userSettings)); }
    function openSettings() { switchUI('settings-mode'); updateSettingsUI(); }
    function closeSettings() { switchUI('view-mode'); }

    let board = null; let game = new Chess(); let currentSide = 'white';
    
    function highlightLastMove(move) {
        if(!userSettings.highlight) return;
        $('#board .square-55d63').removeClass('highlight-square');
        if(move) { $('#board .square-' + move.from).addClass('highlight-square'); $('#board .square-' + move.to).addClass('highlight-square'); }
    }
    
    // FORCE IMMEDIATE VISUAL UPDATE FOR POSITION CHANGES
    function updateBoardDisplay(fen) {
        board.position(fen, false); // false = no animation
    }
    
    function pieceThemeUrl(piece) {
        const style = userSettings.pieceStyle || 'wikipedia';
        const base = 'https://raw.githubusercontent.com/lichess-org/lila/master/public/piece/';
        
        if (style === 'wikipedia') return base + 'cburnett/' + piece + '.svg';
        if (style === 'alpha') return base + 'alpha/' + piece + '.svg';
        if (style === 'uscf') return base + 'california/' + piece + '.svg';
        if (style === 'merida') return base + 'merida/' + piece + '.svg';
        if (style === 'maestro') return base + 'maestro/' + piece + '.svg';
        if (style === 'leipzig') return base + 'leipzig/' + piece + '.svg';
        if (style === 'tatiana') return base + 'tatiana/' + piece + '.svg';
        if (style === 'cardinal') return base + 'cardinal/' + piece + '.svg';
        
        return base + 'cburnett/' + piece + '.svg'; 
    }

    // --- DRAG HANDLER (GEFIXT + LOCK) ---
    function onDragStart (source, piece) { 
        // Generelle Checks
        if (isPaused) return false; 
        if (game.game_over()) return false; 
        if (isBotThinking) return false; // LOCK BOARD IF BOT IS THINKING

        // Regel 1: Man darf immer nur die Farbe ziehen, die gerade am Zug ist
        if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
            (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
            return false;
        }

        // Regel 2: Im TRAINING und BOT Modus darf man NIEMALS die gegnerischen Figuren anfassen.
        if (mode === 'train' || mode === 'bot') {
            if ((currentSide === 'white' && piece.search(/^b/) !== -1) || 
                (currentSide === 'black' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }
        
        setTimeout(() => {
            const draggedPieces = document.querySelectorAll('img[src*="piece"]');
            draggedPieces.forEach(el => {
                el.style.visibility = 'visible !important'; 
                el.style.opacity = '1 !important';
                el.style.zIndex = '999999';
            });
        }, 0);

        return true; 
    }

    function initBoard() {
        const config = { 
            draggable: true, 
            position: game.fen(), 
            onDragStart: onDragStart, 
            onDrop: onDrop, 
            onSnapEnd: onSnapEnd, 
            pieceTheme: pieceThemeUrl,
            moveSpeed: userSettings.animSpeed, 
            snapSpeed: userSettings.animSpeed, 
            showNotation: userSettings.coords, 
            orientation: currentSide 
        };
        if(board) board.destroy(); $('#board').empty(); board = Chessboard('board', config);
        // Ensure touch interactions work on mobile: prevent native touch scrolling inside the board
        const boardEl = document.getElementById('board');
        if (boardEl) {
            boardEl.addEventListener('touchstart', (ev) => { if (window.innerWidth <= 768) ev.preventDefault(); }, { passive: false });
        }
        const history = game.history({verbose:true}); if(history.length > 0) highlightLastMove(history[history.length-1]);
        setTimeout(() => { board.resize(); drawShapes(); }, 100);
    }

    let mode = 'view'; let editingId = null; let repertoire = JSON.parse(localStorage.getItem('chessRepertoire_v3')) || { white: [], black: [] };
    let currentComments = {}; 
    let currentShapes = {}; 
    let trainingQueue = []; let currentTrainLine = null; let currentMoveIndex = 0;

    function getCleanFen() { return game.fen().split(' ').slice(0, 4).join(' '); }
    
    function onDrop (source, target) {
        let moveObj = { from: source, to: target, promotion: 'q' }; 
        let move = game.move(moveObj);
        if (move === null) return 'snapback';
        
        if(move.captured) playSound('capture'); 
        else playSound('move'); 
        highlightLastMove(move);
        
        return new Promise((resolve) => {
            setTimeout(() => {
                if (mode === 'add') { 
                    updatePgnDisplay(); 
                    loadNoteForCurrentPos(); 
                } 
                else if (mode === 'train') { 
                    handleTrainingMove(move); 
                } 
                else if (mode === 'bot') { 
                    updateBotStatus("Bot denkt nach...", "neutral");
                    isBotThinking = true;
                    setTimeout(makeBotMove, 500); 
                }
                else if (mode === 'view') { 
                    updateViewSearch(); 
                }
                
                if (isEngineRunning && mode !== 'bot' && mode !== 'train') {
                    setTimeout(startEvaluation, 50);
                }
                resolve();
            }, 50);
        });
    }
    
    function onSnapEnd () { 
        setTimeout(() => {
            board.position(game.fen(), false);
        }, 10);
    }

    function forceboardUpdate(fen, callback) {
    board.position(fen, false);
    setTimeout(() => {
        if (callback) callback();
    }, 100);
    }
    
    function updateViewSearch() { const currentPgn = game.pgn(); if (!currentPgn) { resetBoardSearch(); return; } document.getElementById('search-active-banner').classList.remove('hidden'); renderList(currentPgn); }
    
    function resetBoardSearch() { 
        game.reset(); board.position(game.fen()); $('#board .square-55d63').removeClass('highlight-square'); document.getElementById('search-active-banner').classList.add('hidden'); renderList(null); 
        if(isEngineRunning && engine) engine.postMessage('stop');
        document.getElementById('eval-fill').style.height = '50%';
        document.getElementById('eval-score').innerText = '0.0';
        drawShapes();
    }
    
    function getGroupedLines(side, filterPgn = null) { const groups = {}; repertoire[side].forEach(line => { if (filterPgn && !line.pgn.startsWith(filterPgn)) return; const cat = line.category || 'Allgemein'; if (!groups[cat]) groups[cat] = []; groups[cat].push(line); }); return groups; }
    function setSide(color) { currentSide = color; $('.color-btn').removeClass('active'); $(`.color-btn:contains('${color === 'white' ? 'Weiß' : 'Schwarz'}')`).addClass('active'); board.orientation(color); resetBoardSearch(); }

    function toggleCategory(catEscaped) {
        if (expandedCategories[catEscaped]) delete expandedCategories[catEscaped];
        else expandedCategories[catEscaped] = true;
        renderList(game.pgn());
    }

    function exportData() {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(repertoire));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "chess_repertoire_" + new Date().toISOString().slice(0,10) + ".json");
        document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove();
    }
    function importData(input) {
        const file = input.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const newRepertoire = JSON.parse(e.target.result);
                if (newRepertoire.white && newRepertoire.black) {
                    if(confirm("Warnung: Deine aktuellen Daten werden überschrieben. Fortfahren?")) { repertoire = newRepertoire; saveData(); renderList(); alert("Daten erfolgreich geladen!"); }
                } else { alert("Ungültige Datei."); }
            } catch (err) { alert("Fehler beim Lesen der Datei."); }
        };
        reader.readAsText(file);
    }
    
    // --- REPETITION LOGIC ---
    function updateRepetitionButtonState() {
        const btnFooter = document.getElementById('train-toggle-btn');
        if (!currentTrainLine || !btnFooter) return;
        
        const exists = repertoire[currentSide].some(l => l.pgn === currentTrainLine.pgn && l.category === REPETITION_CAT);
        
        if (exists) {
            btnFooter.innerHTML = '<i class="fas fa-check-circle"></i> Gemeistert (Entfernen)';
            btnFooter.className = 'action-btn remove-repetition';
        } else {
            btnFooter.innerHTML = '<i class="fas fa-bookmark"></i> Wiederholung';
            btnFooter.className = 'action-btn repetition';
        }
    }

    function toggleRepetitionStatus() {
        const exists = repertoire[currentSide].some(l => l.pgn === currentTrainLine.pgn && l.category === REPETITION_CAT);
        
        if (exists) {
            repertoire[currentSide] = repertoire[currentSide].filter(l => !(l.pgn === currentTrainLine.pgn && l.category === REPETITION_CAT));
            saveData();
            updateRepetitionButtonState();
        } else {
            const newLine = JSON.parse(JSON.stringify(currentTrainLine));
            newLine.id = Date.now();
            // Preserve original category name for repetition entries
            newLine.originalCategory = currentTrainLine.originalCategory || currentTrainLine.category;
            newLine.category = REPETITION_CAT;
            repertoire[currentSide].unshift(newLine);
            saveData();
            updateRepetitionButtonState();
        }
    }
    
    function toggleRepetitionFromList(id) {
        const line = repertoire[currentSide].find(l => l.id === id);
        if (!line) return;
        const repIndex = repertoire[currentSide].findIndex(l => l.pgn === line.pgn && l.category === REPETITION_CAT);
        if (repIndex !== -1) { repertoire[currentSide].splice(repIndex, 1); } 
        else { const newLine = JSON.parse(JSON.stringify(line)); newLine.id = Date.now(); newLine.originalCategory = line.category; newLine.category = REPETITION_CAT; repertoire[currentSide].unshift(newLine); }
        saveData(); renderList(game.pgn());
    }

    function addToRepetition(line) {
        const alreadyExists = repertoire[currentSide].some(l => l.pgn === line.pgn && l.category === REPETITION_CAT);
        if (!alreadyExists) {
            const newLine = JSON.parse(JSON.stringify(line)); newLine.id = Date.now(); newLine.originalCategory = line.category; newLine.category = REPETITION_CAT;
            repertoire[currentSide].unshift(newLine); saveData();
            updateRepetitionButtonState();
        }
    }

    function renderList(filterPgn = null) {
        const list = document.getElementById('lines-list'); list.innerHTML = '';
        const groups = getGroupedLines(currentSide, filterPgn);
        
        const repetitionLines = repertoire[currentSide].filter(l => l.category === REPETITION_CAT);
        const repetitionPgns = new Set(repetitionLines.map(l => l.pgn));

        const categories = Object.keys(groups).sort((a,b) => { if(a === REPETITION_CAT) return -1; if(b === REPETITION_CAT) return 1; return a.localeCompare(b); });
        if (categories.length === 0) { list.innerHTML = `<div style="text-align:center; color:var(--text-muted); padding:20px;">Leer.</div>`; return; }
        
        categories.forEach(cat => {
            const catEscaped = cat.replace(/'/g, "\\'"); 
            const isExpanded = expandedCategories[cat]; 
            const arrowClass = isExpanded ? 'expanded' : ''; 
            const contentClass = isExpanded ? 'expanded' : '';
            const specialClass = (cat === REPETITION_CAT) ? 'special-cat' : '';

            const groupDiv = document.createElement('div'); groupDiv.className = 'category-group';
            groupDiv.innerHTML = `
                <div class="category-header ${arrowClass} ${specialClass}" onclick="toggleCategory('${catEscaped}')">
                    <div style="display:flex; align-items:center;"><i class="fas fa-chevron-right"></i><span>${cat}</span></div>
                    <div class="cat-actions" onclick="event.stopPropagation()"><button onclick="startAddingLine('${catEscaped}')"><i class="fas fa-plus"></i></button><button onclick="renameCategory('${catEscaped}')"><i class="fas fa-pen"></i></button><button class="del" onclick="deleteCategory('${catEscaped}')"><i class="fas fa-trash"></i></button></div>
                </div>`;
            const contentDiv = document.createElement('div'); contentDiv.className = `category-content ${contentClass}`;
            
            groups[cat].forEach(line => {
                    // Sort lines to place similar move sequences near each other
                    // Normalize PGN into move tokens and sort by their sequence
                    const normalizeMoves = (pgn) => {
                        if (!pgn) return [];
                        // remove move numbers and results, collapse whitespace
                        const cleaned = pgn.replace(/\d+\.+/g, '')
                                           .replace(/1-0|0-1|1\/2-1\/2|\*/g, '')
                                           .trim();
                        if (!cleaned) return [];
                        return cleaned.split(/\s+/).map(s => s.replace(/\{.*?\}/g, '').trim()).filter(Boolean);
                    };

                    groups[cat].sort((a, b) => {
                        const ma = normalizeMoves(a.pgn || '');
                        const mb = normalizeMoves(b.pgn || '');
                        const common = Math.min(ma.length, mb.length);
                        for (let i = 0; i < common; i++) {
                            if (ma[i] !== mb[i]) return ma[i].localeCompare(mb[i]);
                        }
                        return ma.length - mb.length;
                    });

                const div = document.createElement('div'); 
                const isInRepetition = cat !== REPETITION_CAT && repetitionPgns.has(line.pgn);
                const repetitionClass = isInRepetition ? 'in-repetition' : '';
                div.className = `line-item ${repetitionClass}`;
                
                div.innerHTML = `
                    <span onclick="loadLinePreview(${line.id})">${line.pgn}</span>
                    <div class="line-actions">
                         <button onclick="toggleRepetitionFromList(${line.id})" class="toggle-rep" title="${isInRepetition ? 'Aus Wiederholung entfernen' : 'Zur Wiederholung hinzufügen'}">
                            <i class="${isInRepetition ? 'fas' : 'far'} fa-bookmark" style="${isInRepetition ? 'color:var(--warning)' : ''}"></i>
                        </button>
                        <button onclick="startBotSetup(${line.id})" title="Gegen Bot spielen" style="color:var(--text-muted);">
                            <i class="fas fa-robot"></i>
                        </button>
                        <button onclick="editLine(${line.id})"><i class="fas fa-pen"></i></button>
                        <button class="del" onclick="deleteLine(${line.id})"><i class="fas fa-trash"></i></button>
                    </div>`;
                contentDiv.appendChild(div);
            });
            groupDiv.appendChild(contentDiv); list.appendChild(groupDiv);
        });
    }

    function renameCategory(oldName) { const newName = prompt("Neuer Name:", oldName); if (newName && newName.trim() !== "" && newName !== oldName) { repertoire[currentSide].forEach(line => { if (line.category === oldName) line.category = newName.trim(); }); saveData(); renderList(game.pgn()); } }
    function deleteCategory(catName) { if(confirm(`"${catName}" löschen?`)) { repertoire[currentSide] = repertoire[currentSide].filter(line => line.category !== catName); saveData(); renderList(game.pgn()); } }
    
    function loadLinePreview(id) { 
        const line = repertoire[currentSide].find(l => l.id === id); 
        if(line) { 
            game.load_pgn(line.pgn); board.position(game.fen()); 
            const history = game.history({verbose:true}); if(history.length) highlightLastMove(history[history.length-1]); 
            updateViewSearch(); 
            // Only analyze if engine is on (Performance Fix)
            if (isEngineRunning) startEvaluation();
            drawShapes(); // Shapes laden
        } 
    }
    
    function deleteLine(id) { if(confirm('Löschen?')) { repertoire[currentSide] = repertoire[currentSide].filter(l => l.id !== id); saveData(); renderList(game.pgn()); } }
    function startAddingLine(preselectedCat) { resetBoardSearch(); editingId = null; let cat = (typeof preselectedCat === 'string') ? preselectedCat : ""; prepareEditor("Neue Variante", "", cat, {}); }
    function editLine(id) { const line = repertoire[currentSide].find(l => l.id === id); if (!line) return; editingId = id; prepareEditor("Bearbeiten", line.pgn, line.category, line.comments || {}, line.shapes || {}); }
    
    // UPDATED PREPARE EDITOR (ACCEPTS SHAPES)
    function prepareEditor(title, pgn, category, commentsData, shapesData) { 
        mode = 'add'; switchUI('add-mode'); 
        document.getElementById('category-input').value = category; 
        currentComments = JSON.parse(JSON.stringify(commentsData)); 
        currentShapes = JSON.parse(JSON.stringify(shapesData || {})); // Shapes laden
        
        const datalist = document.getElementById('category-datalist'); datalist.innerHTML = ''; Object.keys(getGroupedLines(currentSide)).forEach(cat => { const opt = document.createElement('option'); opt.value = cat; datalist.appendChild(opt); }); game.reset(); if (pgn) game.load_pgn(pgn); board.position(game.fen()); board.orientation(currentSide); const history = game.history({verbose:true}); if(history.length) highlightLastMove(history[history.length-1]); else $('#board .square-55d63').removeClass('highlight-square'); updatePgnDisplay(); loadNoteForCurrentPos(); 
        drawShapes();
    }
    
    function updatePgnDisplay() { const pgnEl = document.getElementById('pgn-display'); pgnEl.innerText = game.pgn() || "Züge spielen..."; pgnEl.scrollTop = pgnEl.scrollHeight; }
    
    function saveLine() { 
        const pgn = game.pgn(); if (pgn.trim() === '') { alert("Keine Züge."); return; } 
        const catInput = document.getElementById('category-input').value.trim(); 
        const category = catInput || "Allgemein"; 
        const moves = game.history({ verbose: true }); 
        
        // Save Shapes too!
        const lineData = { id: editingId || Date.now(), pgn, category, moves, comments: currentComments, shapes: currentShapes }; 
        
        if (editingId) { const index = repertoire[currentSide].findIndex(l => l.id === editingId); if (index !== -1) repertoire[currentSide][index] = lineData; } else repertoire[currentSide].push(lineData); saveData(); cancelAdd(); 
    }
    function cancelAdd() { mode = 'view'; editingId = null; currentComments = {}; currentShapes = {}; switchUI('view-mode'); resetBoardSearch(); }
    function openSelectionMode() { if (repertoire[currentSide].length === 0) { alert("Nichts zum Üben."); return; } mode = 'selection'; switchUI('selection-mode'); renderSelectionList(); }
    
    function renderSelectionList() {
        const list = document.getElementById('selection-list'); list.innerHTML = '';
        const groups = getGroupedLines(currentSide);
        const term = document.getElementById('search-input').value.toLowerCase();
        
        Object.keys(groups).sort().forEach(cat => {
            const lines = groups[cat].filter(l => l.pgn.toLowerCase().includes(term) || cat.toLowerCase().includes(term));
            if (lines.length > 0) {
                const catClean = cat.replace(/[^a-zA-Z0-9]/g, '_');
                const header = document.createElement('div'); header.className = 'category-header'; 
                header.innerHTML = `<div style="display:flex; align-items:center; gap:10px;"><input type="checkbox" checked onchange="toggleAllSelection(this, '${catClean}')" onclick="event.stopPropagation()"><span>${cat}</span></div>`;
                list.appendChild(header);
                const contentDiv = document.createElement('div'); contentDiv.style.paddingLeft = "15px";
                lines.forEach(l => {
                    const div = document.createElement('label'); div.className = 'line-item'; 
                    div.innerHTML = `<div style="display:flex; align-items:center;"><input type="checkbox" value="${l.id}" checked class="chk-${catClean}"> <span>${l.pgn}</span></div>`; 
                    contentDiv.appendChild(div);
                });
                list.appendChild(contentDiv);
            }
        });
    }
    function toggleAllSelection(source, catClass) { document.querySelectorAll(`.chk-${catClass}`).forEach(cb => cb.checked = source.checked); }
    function startTrainingFromSelection() { 
        const checked = document.querySelectorAll('#selection-list input[type="checkbox"]:not([onchange]):checked'); 
        if (checked.length === 0) return; 
        trainingStats = { correct: 0, wrong: 0, wrongLines: [] };

        // Build selection, avoiding duplicates between natural and repetition entries
        const selectedLines = Array.from(checked).map(c => repertoire[currentSide].find(x => x.id == c.value)).filter(Boolean).map(l => JSON.parse(JSON.stringify(l)));

        // Group by PGN and prefer natural category entries over Wiederholung when both selected
        const byPgn = {};
        selectedLines.forEach(l => {
            if (!byPgn[l.pgn]) byPgn[l.pgn] = [];
            byPgn[l.pgn].push(l);
        });

        const finalList = [];
        Object.keys(byPgn).forEach(pgn => {
            const group = byPgn[pgn];
            const natural = group.filter(x => x.category !== REPETITION_CAT);
            if (natural.length > 0) {
                // use natural entries only
                natural.forEach(n => finalList.push(n));
            } else {
                // only repetition entries selected
                group.forEach(r => {
                    // try to find the line's original category in the full repertoire
                    const orig = repertoire[currentSide].find(x => x.pgn === r.pgn && x.category !== REPETITION_CAT);
                    if (orig) r.originalCategory = orig.category; 
                    finalList.push(r);
                });
            }
        });

        trainingQueue = finalList.sort(() => Math.random() - 0.5);
        totalTrainingLines = trainingQueue.length;
        mode = 'train'; switchUI('train-mode'); nextTrainingLine(); 
    }
    
    function continueFromNote() { $('#training-note-display').fadeOut(); isPaused = false; if (pendingNextAction) { const action = pendingNextAction; pendingNextAction = null; action(); } }
    function processGameStep(nextAction) { 
        const fen = getCleanFen(); 
        const note = currentTrainLine.comments[fen]; 
        
        // Load shapes for this step
        if(currentTrainLine.shapes && currentTrainLine.shapes[fen]) {
            currentShapes = {[fen]: currentTrainLine.shapes[fen]}; 
        } else {
            currentShapes = {};
        }
        drawShapes();

        if (note) { $('#note-text').text(note); $('#training-note-display').css('display', 'flex').hide().fadeIn(); isPaused = true; pendingNextAction = nextAction; } else { $('#training-note-display').hide(); if (nextAction) nextAction(); } 
    }
    
    function nextTrainingLine() { 

        if (trainingQueue.length === 0) { 
            showTrainingResults(); // Changed from stopTraining()
            return; 
        }

        if (trainingQueue.length === 0) { stopTraining(); return; } 
        updateProgress();
        currentTrainLine = trainingQueue[0]; 
        
        // When practicing a repetition entry, show its natural/original category if available
        const displayCat = (currentTrainLine.category === REPETITION_CAT && currentTrainLine.originalCategory) ? currentTrainLine.originalCategory : currentTrainLine.category;
        document.getElementById('train-category-display').innerText = displayCat; 
        updateRepetitionButtonState();
        
        $('#training-note-display').hide(); isPaused = false;
        
        let tGame = new Chess(); tGame.load_pgn(currentTrainLine.pgn); 
        currentTrainLine.moveHistory = tGame.history({ verbose: true }); 
        game.reset(); board.position(game.fen()); board.orientation(currentSide); currentMoveIndex = 0; 
        
        // Reset Visuals
        $('#board .square-55d63').removeClass('highlight-square'); 
        currentShapes = {}; drawShapes(); 

        updateTrainStatus("Dein Zug", "neutral"); 
        processGameStep(() => { if (currentSide === 'black') playBotMove(); });
    }

    function updateProgress() {
        const remaining = trainingQueue.length;
        const done = totalTrainingLines - remaining;
        const percent = (done / totalTrainingLines) * 100;
        document.getElementById('progress-fill').style.width = percent + '%';
        document.getElementById('progress-text-right').innerText = `${done} / ${totalTrainingLines}`;
    }

        function handleTrainingMove(move) { 
            const expected = currentTrainLine.moveHistory[currentMoveIndex]; 
            if (!expected || (move.from === expected.from && move.to === expected.to)) { 
                currentMoveIndex++; 
                setTimeout(() => {
                    processGameStep(() => {
                        if (!expected || currentMoveIndex >= currentTrainLine.moveHistory.length) { 
                            successLine(); 
                        } 
                        else { 
                            setTimeout(playBotMove, 400); 
                        }
                    });
                }, 100);
            } else { 
                playSound('error'); 
                updateTrainStatus("FALSCH!", "error"); 
                
                // Track wrong move
                if (!trainingStats.wrongLines.some(l => l.id === currentTrainLine.id)) {
                    trainingStats.wrongLines.push({
                        id: currentTrainLine.id,
                        pgn: currentTrainLine.pgn,
                        category: currentTrainLine.category
                    });
                }
                
                // IMMEDIATE RESET FOR WRONG MOVES
                setTimeout(() => { 
                    game.undo(); 
                    board.position(game.fen(), false);
                    setTimeout(() => {
                        updateTrainStatus("Dein Zug", "neutral"); 
                        drawShapes(); 
                    }, 100);
                }, 500); 
            } 
        }
    
    function playBotMove() { 
        if (currentMoveIndex < currentTrainLine.moveHistory.length) { 
            const botMove = currentTrainLine.moveHistory[currentMoveIndex]; 
            game.move(botMove); 
            
            board.position(game.fen(), false);
            
            setTimeout(() => {
                playSound('move'); 
                highlightLastMove(botMove); 
                currentMoveIndex++; 
                
                setTimeout(() => {
                    processGameStep(() => { 
                        if (currentMoveIndex >= currentTrainLine.moveHistory.length) {
                            successLine(); 
                        }
                    });
                    if(isEngineRunning) setTimeout(startEvaluation, 300);
                }, 100);
            }, 50);
        } 
    }
    
    function successLine() { 
        if (!trainingStats.wrongLines.some(l => l.id === currentTrainLine.id)) {
            trainingStats.correct++;
        }
        playSound('capture'); 
        trainingQueue.shift(); 
        const boardEl = document.getElementById('board'); 
        boardEl.style.boxShadow = "0 0 20px var(--success)"; 
        updateTrainStatus("RICHTIG!", "success"); 
        setTimeout(() => { boardEl.style.boxShadow = "var(--shadow)"; 
        updateTrainStatus("...", "neutral"); nextTrainingLine(); 
        }, 800);
    }
    
    function updateTrainStatus(t, className) { const e = document.getElementById('train-status'); e.innerText = t; e.className = `status-badge ${className}`; }
    function repeatLater() { trainingQueue.push(trainingQueue.shift()); nextTrainingLine(); }
    function stopTraining() { mode = 'view'; switchUI('view-mode'); resetBoardSearch(); isPaused = false; }
    function switchUI(id) { 
        document.querySelectorAll('.controls-area > div').forEach(d => d.classList.add('hidden'));
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('hidden');
            // Reset internal scroll so the menu content is visible top-aligned
            try { el.scrollTop = 0; } catch (e) {}
            const dash = el.querySelector('.training-dashboard'); if (dash) dash.scrollTop = 0;
        }
        if(id === 'view-mode' || id === 'settings-mode') document.querySelector('.header-row').classList.remove('hidden'); else document.querySelector('.header-row').classList.add('hidden');
        setTimeout(() => board.resize(), 200);
    }
    function saveData() { localStorage.setItem('chessRepertoire_v3', JSON.stringify(repertoire)); }

    function loadNoteForCurrentPos() {
        const fen = getCleanFen();
        const noteEl = document.getElementById('move-note-input');
        if(noteEl) noteEl.value = currentComments[fen] || "";
        drawShapes();
    }
    document.getElementById('move-note-input').addEventListener('input', function() {
        const fen = getCleanFen();
        if(this.value.trim() === "") delete currentComments[fen];
        else currentComments[fen] = this.value;
    });

    // --- ARROW DRAWING LOGIC ---
    const boardWrapper = document.getElementById('board-wrapper');
    const svgOverlay = document.getElementById('arrow-overlay');
    // Detect touch devices (phone/tablet)
    const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    let isDrawing = false;
    let startSquare = null;

    function getSquareFromCoords(clientX, clientY) {
        const rect = boardWrapper.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const squareSize = rect.width / 8;
        
        let col = Math.floor(x / squareSize);
        let row = Math.floor(y / squareSize);
        
        if(currentSide === 'black') {
            col = 7 - col;
            row = 7 - row;
        }
        
        const files = ['a','b','c','d','e','f','g','h'];
        const ranks = ['8','7','6','5','4','3','2','1'];
        
        if(col >= 0 && col <= 7 && row >= 0 && row <= 7) {
            return files[col] + ranks[row];
        }
        return null;
    }

    boardWrapper.addEventListener('mousedown', (e) => {
        // Disable drawing on touch devices (phones/tablets)
        if (isTouchDevice) return;
        if(e.button === 2) { // Right Click
            isDrawing = true;
            startSquare = getSquareFromCoords(e.clientX, e.clientY);
            e.preventDefault();
        }
    });

    boardWrapper.addEventListener('mouseup', (e) => {
        if (isTouchDevice) return;
        if(isDrawing && e.button === 2) {
            const endSquare = getSquareFromCoords(e.clientX, e.clientY);
            if(startSquare && endSquare) {
                let color = 'green';
                if(e.shiftKey) color = 'red';
                else if(e.altKey) color = 'blue';
                else if(e.ctrlKey) color = 'yellow';

                addShape(startSquare, endSquare, color);
            }
            isDrawing = false;
            startSquare = null;
            e.preventDefault();
        }
    });

    boardWrapper.addEventListener('contextmenu', (e) => { e.preventDefault(); });

    // NEW FUNCTION: CLEAR SHAPES
    function clearShapesForCurrentPos() {
        const fen = getCleanFen();
        delete currentShapes[fen];
        drawShapes();
    }

    // Keyboard shortcut: Shift+Z clears all arrows for current position
    document.addEventListener('keydown', (e) => {
        if ((e.key === 'Z' || e.key === 'z') && e.shiftKey) {
            clearShapesForCurrentPos();
            // brief visual cue on the board
            const boardEl = document.getElementById('board');
            if (boardEl) {
                boardEl.classList.add('flash-clear-shapes');
                setTimeout(() => boardEl.classList.remove('flash-clear-shapes'), 220);
            }
            e.preventDefault();
        }
    });

    // If on touch device, hide the clear-shapes buttons (all) because drawing is disabled
    if (isTouchDevice) {
        document.querySelectorAll('.clear-shapes-btn').forEach(btn => btn.classList.add('hidden'));
    }

    function addShape(from, to, color) {
        const fen = getCleanFen();
        if(!currentShapes[fen]) currentShapes[fen] = [];
        
        const existingIdx = currentShapes[fen].findIndex(s => s.from === from && s.to === to);
        
        if (existingIdx !== -1) {
            currentShapes[fen].splice(existingIdx, 1);
        } else {
            currentShapes[fen].push({ from, to, color });
        }
        drawShapes();
    }

    function drawShapes() {
        const fen = getCleanFen();
        const shapes = currentShapes[fen] || [];
        svgOverlay.innerHTML = ''; 
        
        // Define arrow marker (SMALLER & THINNER)
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        ['green', 'red', 'blue', 'yellow'].forEach(c => {
            const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
            marker.setAttribute("id", `arrowhead-${c}`);
            marker.setAttribute("markerWidth", "4");  // Viel kleiner
            marker.setAttribute("markerHeight", "4"); 
            marker.setAttribute("refX", "2");
            marker.setAttribute("refY", "2");
            marker.setAttribute("orient", "auto");
            
            const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            polygon.setAttribute("points", "0 0, 4 2, 0 4"); // Feinere Spitze
            polygon.setAttribute("fill", getColorCode(c));
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
        });
        svgOverlay.appendChild(defs);

        shapes.forEach(shape => {
            if(shape.from === shape.to) {
                drawCircle(shape.from, shape.color);
            } else {
                drawArrow(shape.from, shape.to, shape.color);
            }
        });
    }

    function getColorCode(c) {
        if(c === 'green') return '#22c55e';
        if(c === 'red') return '#ef4444';
        if(c === 'blue') return '#3b82f6';
        if(c === 'yellow') return '#eab308';
        return '#22c55e';
    }

    function getSquareCenter(sq) {
        const rect = boardWrapper.getBoundingClientRect();
        const size = rect.width / 8;
        const files = ['a','b','c','d','e','f','g','h'];
        const ranks = ['8','7','6','5','4','3','2','1'];
        
        let col = files.indexOf(sq.charAt(0));
        let row = ranks.indexOf(sq.charAt(1));
        
        if(currentSide === 'black') {
            col = 7 - col;
            row = 7 - row;
        }
        
        return {
            x: col * size + size / 2,
            y: row * size + size / 2
        };
    }

    function drawArrow(from, to, color) {
        const start = getSquareCenter(from);
        const end = getSquareCenter(to);
        
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", start.x);
        line.setAttribute("y1", start.y);
        line.setAttribute("x2", end.x);
        line.setAttribute("y2", end.y);
        line.setAttribute("stroke", getColorCode(color));
        line.setAttribute("stroke-width", "5"); // Thinner line
        line.setAttribute("opacity", "0.8");
        line.setAttribute("marker-end", `url(#arrowhead-${color})`);
        
        svgOverlay.appendChild(line);
    }

    function drawCircle(sq, color) {
        const center = getSquareCenter(sq);
        const rect = boardWrapper.getBoundingClientRect();
        const size = rect.width / 8;
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", center.x);
        circle.setAttribute("cy", center.y);
        circle.setAttribute("r", size / 2.2); 
        circle.setAttribute("stroke", getColorCode(color));
        circle.setAttribute("stroke-width", "4");
        circle.setAttribute("fill", "none");
        circle.setAttribute("opacity", "0.8");
        
        svgOverlay.appendChild(circle);
    }
    
    window.addEventListener('resize', () => {
        board.resize();
        setTimeout(drawShapes, 50);
    });


    // --- STOCKFISH ENGINE LOGIC (SYNC FIX) ---
    let engine = null;
    let isEngineRunning = false;

    // HARD RESET FUNCTION
    function restartEngine() {
        if(engine) engine.terminate();
        const stockfishUrl = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.0/stockfish.js';
        
        return fetch(stockfishUrl)
            .then(response => response.blob())
            .then(blob => {
                const localUrl = URL.createObjectURL(blob);
                engine = new Worker(localUrl);
                engine.onmessage = function(event) {
                    const line = event.data;
                    
                    // EVALUATION LOGIC (Only if NOT in bot mode)
                    if (mode !== 'bot' && typeof line === 'string' && line.startsWith('info') && line.includes('score')) { 
                        parseEvaluation(line); 
                    }
                    
                    // BOT MOVE LOGIC
                    if (mode === 'bot' && line.startsWith('bestmove')) {
                        const best = line.split(' ')[1];
                        if(best) {
                            const moveResult = game.move({ from: best.substring(0,2), to: best.substring(2,4), promotion: 'q' });
                            
                            if (moveResult) {
                                board.position(game.fen(), false);
                                
                                setTimeout(() => {
                                    playSound('move');
                                    highlightLastMove({ from: best.substring(0,2), to: best.substring(2,4) });
                                    
                                    setTimeout(() => {
                                        isBotThinking = false;
                                        updateBotStatus("Dein Zug", "neutral");
                                        
                                        if(game.game_over()) {
                                            setTimeout(() => { 
                                                alert("Spiel vorbei!"); 
                                                stopBotGame(); 
                                            }, 500);
                                        }
                                    }, 150);
                                }, 100);
                            }
                        }
                    }
                };
                engine.postMessage('uci');
            });
    }

    async function initEngine() {
        if(!engine) await restartEngine();
    }

    function toggleEngine() {
        isEngineRunning = !isEngineRunning;
        updateSettingsUI();
        const bar = document.getElementById('eval-bar-container');
        if (isEngineRunning) {
            initEngine().then(startEvaluation);
            bar.classList.remove('hidden');
        } else {
            bar.classList.add('hidden');
            if(engine) engine.postMessage('stop');
        }
    }

    function startEvaluation() {
        if (!isEngineRunning || !engine) return;
        engine.postMessage('stop');
        engine.postMessage('position fen ' + game.fen());
        engine.postMessage('go depth 15');
    }
    
    // --- NEUE FUNKTIONEN FÜR BOT SPIEL ---
    function startBotSetup(lineId) {
        // FORCE RESTART ENGINE TO CLEAR OLD STATE
        restartEngine().then(() => {
            const line = repertoire[currentSide].find(l => l.id === lineId);
            if(!line) return;
            selectedBotLine = line;
            
            document.getElementById('bot-line-preview').innerText = line.pgn;
            document.getElementById('elo-display').innerText = botElo;
            document.getElementById('elo-slider').value = botElo;
            
            switchUI('bot-setup-mode');
        });
    }
    
    function updateEloDisplay(val) {
        botElo = val;
        document.getElementById('elo-display').innerText = val;
    }
    
    function launchBotGame() {
        if(!selectedBotLine) return;
        game.load_pgn(selectedBotLine.pgn);
        board.position(game.fen());
        board.orientation(currentSide);
        document.getElementById('eval-bar-container').classList.add('hidden');
        document.getElementById('bot-play-elo').innerText = `(${botElo})`;
        mode = 'bot';
        botGameActive = true;
        isBotThinking = false;
        switchUI('bot-play-mode');
        updateBotStatus("Spiel gestartet", "neutral");
        
        // Initial configuration for the game
        engine.postMessage('ucinewgame');
        
        if (game.turn().charAt(0) !== currentSide.charAt(0)) {
            updateBotStatus("Bot zieht...", "neutral");
            isBotThinking = true;
            setTimeout(makeBotMove, 1000);
        }
    }
    
    function makeBotMove() {
        if(!botGameActive || !engine) return;
        if(game.game_over()) return;
        const skill = Math.floor( (botElo - 500) / (3300 - 500) * 20 );
        const clampedSkill = Math.max(0, Math.min(20, skill));
        const moveTime = Math.max(100, (botElo / 3300) * 1000); 
        
        engine.postMessage('stop');
        engine.postMessage(`setoption name Skill Level value ${clampedSkill}`);
        engine.postMessage('position fen ' + game.fen());
        engine.postMessage(`go movetime ${moveTime}`);
    }
    
    function updateBotStatus(msg, type) {
        const el = document.getElementById('bot-status');
        el.innerText = msg;
        el.className = `status-badge ${type}`;
    }
    
    function stopBotGame() {
        botGameActive = false;
        isBotThinking = false;
        mode = 'view';
        if(isEngineRunning) document.getElementById('eval-bar-container').classList.remove('hidden');
        switchUI('view-mode');
        resetBoardSearch();
    }

    function parseEvaluation(line) {
        const tokens = line.split(' ');
        let scoreIdx = tokens.indexOf('score');
        if (scoreIdx !== -1) {
            let type = tokens[scoreIdx + 1];
            let value = parseInt(tokens[scoreIdx + 2]);
            if (game.turn() === 'b') value = -value; 

            let score = 0;
            if (type === 'mate') {
                score = (value > 0) ? 100 : -100;
                document.getElementById('eval-score').innerText = `M${Math.abs(value)}`;
            } else {
                score = value / 100;
                document.getElementById('eval-score').innerText = (score > 0 ? '+' : '') + score.toFixed(1);
                if (score > 5) score = 5; if (score < -5) score = -5;
            }
            updateEvalBar(score);
        }
    }

    function updateEvalBar(score) {
        let percent = 50;
        if (score === 100) percent = 100; else if (score === -100) percent = 0;
        else percent = 50 + (score * 10);
        if (percent > 100) percent = 100; if (percent < 0) percent = 0;

        const fill = document.getElementById('eval-fill');
        const text = document.getElementById('eval-score');
        fill.style.height = percent + '%';
        
        if (score >= 0) {
            text.style.top = 'auto'; text.style.bottom = '5px'; text.style.color = '#333'; 
        } else {
            text.style.top = '5px'; text.style.bottom = 'auto'; text.style.color = '#f8fafc'; 
        }
    }

        function showTrainingResults() {
        const total = trainingStats.correct + trainingStats.wrongLines.length;
        const accuracy = total > 0 ? Math.round((trainingStats.correct / total) * 100) : 0;
        
        // Update stats
        document.getElementById('stat-correct').innerText = trainingStats.correct;
        document.getElementById('stat-wrong').innerText = trainingStats.wrongLines.length;
        document.getElementById('stat-accuracy').innerText = accuracy + '%';
        
        // Determine performance level
        const icon = document.getElementById('results-icon');
        const title = document.getElementById('results-title');
        const subtitle = document.getElementById('results-subtitle');
        
        if (accuracy === 100) {
            icon.className = 'results-icon perfect';
            icon.innerHTML = '<i class="fas fa-trophy"></i>';
            title.innerText = 'Perfekt!';
            subtitle.innerText = 'Du hast alle Varianten gemeistert!';
        } else if (accuracy >= 70) {
            icon.className = 'results-icon good';
            icon.innerHTML = '<i class="fas fa-star"></i>';
            title.innerText = 'Gut gemacht!';
            subtitle.innerText = 'Starke Leistung, weiter so!';
        } else {
            icon.className = 'results-icon needs-work';
            icon.innerHTML = '<i class="fas fa-chart-line"></i>';
            title.innerText = 'Training abgeschlossen';
            subtitle.innerText = 'Übung macht den Meister!';
        }
        
        // Handle wrong lines section
        const container = document.getElementById('wrong-lines-container');
        const actionsDiv = document.getElementById('results-actions');
        
        if (trainingStats.wrongLines.length > 0) {
            container.innerHTML = `
                <div class="wrong-lines-section">
                    <div class="wrong-lines-header">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>Fehlerhafte Varianten (${trainingStats.wrongLines.length})</span>
                    </div>
                    <div class="wrong-lines-list">
                        ${trainingStats.wrongLines.map(line => `
                            <div class="wrong-line-item">${line.pgn}</div>
                        `).join('')}
                    </div>
                </div>
                <div class="results-question">
                    <i class="fas fa-bookmark" style="color: var(--warning); margin-right: 8px;"></i>
                    Diese Varianten zur Wiederholung hinzufügen?
                </div>
            `;
            
            actionsDiv.innerHTML = `
                <button class="results-btn primary" onclick="addWrongLinesToRepetition()">
                    <i class="fas fa-check"></i> Ja, hinzufügen
                </button>
                <button class="results-btn secondary" onclick="closeTrainingResults()">
                    <i class="fas fa-times"></i> Nein, danke
                </button>
            `;
        } else {
            container.innerHTML = `
                <div class="no-wrong-lines">
                    <i class="fas fa-check-circle"></i>
                    <p>Keine Fehler!</p>
                    <span>Du hast alle Varianten perfekt gespielt.</span>
                </div>
            `;
            
            actionsDiv.innerHTML = `
                <button class="results-btn secondary" onclick="closeTrainingResults()">
                    <i class="fas fa-times"></i> Schließen
                </button>
            `;
        }
        
        // Show overlay
        document.getElementById('training-results-overlay').style.display = 'flex';
    }

    function addWrongLinesToRepetition() {
        trainingStats.wrongLines.forEach(wrongLine => {
            const alreadyExists = repertoire[currentSide].some(l => 
                l.pgn === wrongLine.pgn && l.category === REPETITION_CAT
            );
            
            if (!alreadyExists) {
                const newLine = JSON.parse(JSON.stringify(
                    repertoire[currentSide].find(l => l.id === wrongLine.id)
                ));
                newLine.id = Date.now() + Math.random(); // Unique ID
                newLine.category = REPETITION_CAT;
                repertoire[currentSide].unshift(newLine);
            }
        });
        
        saveData();
        closeTrainingResults();
    }

    function closeTrainingResults() {
        document.getElementById('training-results-overlay').style.display = 'none';
        stopTraining();
    }

    applySettings(); initBoard(); setSide('white'); window.onresize = board.resize;
</script>
</body>
</html>